
# PROJECT-PHASE-2

# PROJECT MEMBERS:

**61827** | **Muhammad Mashood Ahmed**
  
*61819* | *Nausherwan Khan Adil*
## Project Description 
The primary goal of this project was to comprehend the significance of a compiler. As a computer science student, it's important to understand how to use a compiler and what goes on inside the tool we're using. It gives us the ability to create and deploy our own domain-specific language. The compiler's architecture allows for the use of formal methods that are seldom used in other programming languages. Compiler review is a good way to learn about compilers.
Compiler analysis is a great way to get acquainted with systematic methods. As a result, studying compiler will teach us a lot. That was also the aim of our project; we learned how to use a subset of a broad language, as well as its specifications and CFG. We also learned how to build a lexical analyzer and develop a parser using lexical specifications.

## Sample Language Used 
MINIJAVA is the programming language that we used to build our parser. Minijava is a condensed and updated version of the Java programming language. It is a teaching-oriented programming language based on the Java language from Sun Microsystems. The core of the MiniJava environment is a simplified version of the standard Java release, created to alleviate the fear that beginners experience when confronted with it.The core of the MiniJava environment is a simplified version of the standard Java release, created to help beginners overcome their fear of a system as complex as the Java environment. The sense of a Java program determines the intent of a MiniJava program. Every MiniJava program is a complete Java program that adheres to Java semantics. It supports classes as well as a limited number of users.
It has a few hierarchical control constructors, as well as classes and restricted inheritance. It also has simple data types and simple data types. MiniJava is a single file that lacks a package declaration (and thus does not refer to the default package) as well as imports. One or more Java classes make up this object. There are no interface classes, subclasses, or nested classes in the classes, making them simple and easy to understand.

# PROBLEM FACED
## PROBLEM 1: FLEX INSTALLATION IN KALI LINUX
When we were putting together our lexical analyzer, we ran into a lot of problems. Our lex file was not developed due to linux installation problems, but after several attempts, we finally succeeded.

## Problem 2: NOT FROM JAVA BACKGROUND
So, prior to this project, neither of us knew anything about Java. Our domain region is react native (javaScript), but we figured why not give it a shot and try something new? As a result, we chose MiniJava, which is a smaller part of the Java language. We had a lot of problems at first because we didn't understand how it worked, how to declare variables and methods. However, once we studied and gained a basic understanding of it, we had no problems.

## Problem 3: Issue With Github
Github is complicated platform and is rearly used in our university and ask by our teachers. We have to learn about the Github from Youtube and have to practice about it before doing the official work.

## Problem 4: YACC Compilation
When our lex and yacc files were combined, it meant (.l & .y extension file). There were many errors in its compilations, such as (undefined reference or function in y file, redeifintions, declaration and so on). We were completely unaware of them because we had never worked in such an area. Since it was our first time designing a parser, most of the errors were unfamiliar to us, so we did some research, watched some videos, books and documentation.
